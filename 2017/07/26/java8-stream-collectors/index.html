<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java,Java8,函数式编程," />










<meta name="description" content="collect是一个归约操作，就像reduce一样可以接受各种做法作为参数，将流中的元素累积成一个汇总结果。这里主要学习一下用Collectors类创建和使用收集器，将数据流归约为一个值，汇总：归约的特殊情况，数据分组和分区，开发自己的自定义收集器">
<meta name="keywords" content="Java,Java8,函数式编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8-流收集数据">
<meta property="og:url" content="http://yoursite.com/2017/07/26/java8-stream-collectors/index.html">
<meta property="og:site_name" content="darcy he">
<meta property="og:description" content="collect是一个归约操作，就像reduce一样可以接受各种做法作为参数，将流中的元素累积成一个汇总结果。这里主要学习一下用Collectors类创建和使用收集器，将数据流归约为一个值，汇总：归约的特殊情况，数据分组和分区，开发自己的自定义收集器">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://static.zybuluo.com/csqiang1992/wwtgcbuj14dw7tyro1yh6sw0/java8-groupby-1.png">
<meta property="og:image" content="http://static.zybuluo.com/csqiang1992/kcgv6uq4eptigqnx9qc832ww/java8-collectors-1.png">
<meta property="og:image" content="http://static.zybuluo.com/csqiang1992/g8cr6j29ixe0u06oq9f1dgm2/java8-collectors-2.png">
<meta property="og:image" content="http://static.zybuluo.com/csqiang1992/x2vg4kkxx9c17ipxactmycf7/java8-collectors-3.png">
<meta property="og:image" content="http://static.zybuluo.com/csqiang1992/jl7hvwfr1cfmr73zwn7l4za2/java8-sequentail-reduce-1.png">
<meta property="og:updated_time" content="2018-10-20T11:50:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java8-流收集数据">
<meta name="twitter:description" content="collect是一个归约操作，就像reduce一样可以接受各种做法作为参数，将流中的元素累积成一个汇总结果。这里主要学习一下用Collectors类创建和使用收集器，将数据流归约为一个值，汇总：归约的特殊情况，数据分组和分区，开发自己的自定义收集器">
<meta name="twitter:image" content="http://static.zybuluo.com/csqiang1992/wwtgcbuj14dw7tyro1yh6sw0/java8-groupby-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/07/26/java8-stream-collectors/"/>





  <title>Java8-流收集数据 | darcy he</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">darcy he</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">求知 孤勇 温柔</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/26/java8-stream-collectors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="darcy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/self.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="darcy he">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java8-流收集数据</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T23:54:19+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/07/26/java8-stream-collectors/" class="leancloud_visitors" data-flag-title="Java8-流收集数据">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>collect是一个归约操作，就像reduce一样可以接受各种做法作为参数，将流中的元素累积成一个汇总结果。这里主要学习一下用Collectors类创建和使用收集器，将数据流归约为一个值，汇总：归约的特殊情况，数据分组和分区，开发自己的自定义收集器</p>
</blockquote>
<a id="more"></a>
<hr>
<h2 id="收集器简介"><a href="#收集器简介" class="headerlink" title="收集器简介"></a>收集器简介</h2><ul>
<li>函数式编程相对于指令式编程的一个主要优势：你只需指出希望的结果——“做什么”，而不用操心执行的步骤——“如何做”。</li>
<li>Java 8的流支持两种类型的操作：中间操作（如filter或map）和终端操作（如count、findFirst、forEach和reduce）。中间操作可以链接起来，将一个流转换为另一个流。这些操作不会消耗流，其目的是建立一个流水线。与此相反，终端操作会消耗流，以产生一个最终结果</li>
<li>传递给collect方法的参数是<strong>Collector接口</strong>的一个实现，也就是给Stream中元素做汇总的方法。<code>toList</code>只是说“按顺序给每个元素生成一个列表”；<code>groupingBy</code>说的是“生成一个Map，它的键是xx，值则是那些元素的列表”。</li>
<li>对流调用collect方法将对流中的元素触发一个归约操作（由Collector来参数化） 。</li>
<li>一般来说，Collector会对元素应用一个转换函数（很多时候是不体现任何效果的恒等转换，例如toList），并将结果累积在一个数据结构中，从而产生这一过程的最终输出。</li>
<li><code>Collector</code><strong>接口中方法的实现决定了如何对流执行归约操作</strong>。Collectors实用类提供了很多静态工厂方法，可以方便地创建常见<strong>收集器</strong>的实例，最直接和最常用的收集器是toList静态方法，它会把流中所有的元素收集到一个List中.</li>
<li><code>java.util.stream.Collectors</code>中预定义了大量的收集器．</li>
</ul>
<p><strong>demo</strong></p>
<ul>
<li>按照货币类型进行分组．</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupingTransactions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Transaction&gt; transactions =</span><br><span class="line">            Arrays.asList(<span class="keyword">new</span> Transaction(Currency.EUR, <span class="number">1500.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.USD, <span class="number">2300.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.GBP, <span class="number">9900.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.EUR, <span class="number">1100.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.JPY, <span class="number">7800.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.CHF, <span class="number">6700.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.EUR, <span class="number">5600.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.USD, <span class="number">4500.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.CHF, <span class="number">3400.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.GBP, <span class="number">3200.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.USD, <span class="number">4600.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.JPY, <span class="number">5700.0</span>),</span><br><span class="line">                    <span class="keyword">new</span> Transaction(Currency.EUR, <span class="number">6800.0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        groupImperatively();</span><br><span class="line">        groupFunctionally();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指令式风格对Transactions List进行分组.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">groupImperatively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Transaction transaction : transactions) &#123;</span><br><span class="line">            Currency currency = transaction.getCurrency();</span><br><span class="line">            List&lt;Transaction&gt; transactionsForCurrency = transactionsByCurrencies.get(currency);</span><br><span class="line">            <span class="keyword">if</span> (transactionsForCurrency == <span class="keyword">null</span>) &#123;</span><br><span class="line">                transactionsForCurrency = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                transactionsByCurrencies.put(currency, transactionsForCurrency);</span><br><span class="line">            &#125;</span><br><span class="line">            transactionsForCurrency.add(transaction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(transactionsByCurrencies);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数式编程风格进行分组</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">groupFunctionally</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = transactions.stream()</span><br><span class="line">                <span class="comment">// groupingBy生成一个Map，它的键是（货币），值则是元素的列表；元素的属性是该键类型</span></span><br><span class="line">                .collect(groupingBy(Transaction::getCurrency));</span><br><span class="line">        System.out.println(transactionsByCurrencies);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Currency currency;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(Currency currency, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.currency = currency;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Currency <span class="title">getCurrency</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> currency;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> currency + <span class="string">" "</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Currency &#123;</span><br><span class="line">        EUR, USD, JPY, GBP, CHF</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h2><ul>
<li>在需要将流项目重组成集合时，一般会使用收集器（Stream方法collect的参数）。再宽泛一点来说，但凡要把流中所有的项目合并成一个结果时就可以用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用counting工厂方法返回的收集器，数一数菜单里有多少种菜</span></span><br><span class="line"><span class="keyword">long</span> howManyDishes = menu.stream().collect(Collectors.counting());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简便写法</span></span><br><span class="line"><span class="keyword">long</span> howManyDishes = menu.stream().count();</span><br></pre></td></tr></table></figure>
<h3 id="查找流中的最大值和最小值"><a href="#查找流中的最大值和最小值" class="headerlink" title="查找流中的最大值和最小值"></a>查找流中的最大值和最小值</h3><ul>
<li>收集器Collectors.maxBy和Collectors.minBy用来计算流中的最大或最小值。这两个收集器接收一个Comparator参数来比较流中的元素。</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>找出菜单中热量最高的菜</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comparingInt接收一个Function&lt;T&gt;, 生成一个Comparator</span></span><br><span class="line">Comparator&lt;Dish&gt; dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);</span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream()</span><br><span class="line">        .collect(maxBy(dishCaloriesComparator));</span><br></pre></td></tr></table></figure>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><ul>
<li><code>Collectors.summingInt</code>可接受一个<strong>把对象映射为求和所需int</strong>的函数，并返回一个收集器；该收集器在传递给普通的collect方法后即执行我们需要的汇总操作。</li>
<li><code>Collectors.summingLong</code>和<code>Collectors.summingDouble</code>方法的作用完全一样，可以用于求和字段为long或double的情况</li>
<li><code>Collectors.averagingInt</code>，<code>averagingLong</code>和<code>averagingDouble</code>可以计算数值的平均数</li>
<li><code>summarizing</code>操作你可以就数出菜单中元素的个数，并得到菜肴热量总和、平均值、最大值和最小值</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>求出菜单列表的总热量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// summingInt(ToIntFunction&lt;? super T&gt; mapper)　(T -&gt; int)</span><br><span class="line">int totalCalories = menu.stream()</span><br><span class="line">        .collect(summingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line">double avgCalories = menu.stream()</span><br><span class="line">        .collect(averagingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line">IntSummaryStatistics menuStatistics = menu.stream()</span><br><span class="line">        .collect(summarizingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line">&gt; output</span><br><span class="line">4300</span><br><span class="line">477.77777777777777</span><br><span class="line">IntSummaryStatistics&#123;count=9, sum=4300, min=120, average=477.777778, max=800&#125;</span><br></pre></td></tr></table></figure>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><ul>
<li>joining工厂方法返回的收集器会把对流中每一个对象应用toString方法得到的所有字符串连接成一个字符串。</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>把菜单中所有菜肴的名称连接起来</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream()</span><br><span class="line">        .map(Dish::getName)</span><br><span class="line">        .collect(joining());</span><br><span class="line"></span><br><span class="line">String menu2 = menu.stream()</span><br><span class="line">        .map(Dish::getName)</span><br><span class="line">        .collect(joining(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure>
<h3 id="广义的归约汇总"><a href="#广义的归约汇总" class="headerlink" title="广义的归约汇总"></a>广义的归约汇总</h3><ul>
<li>讨论的所有收集器，都是一个可以用reducing工厂方法定义的归约过程的特殊情况而已。<code>Collectors.reducing</code>工厂方法是所有这些特殊情况的一般化。</li>
<li>reducing的三个参数<ul>
<li>第一个参数是归约操作的起始值，也是流中没有元素时的返回值，所以很显然对于数值和而言0是一个合适的值。</li>
<li>第二个参数是一个函数引用，将菜肴转换成一个表示其所含热量的int。</li>
<li>第三个参数是一个BinaryOperator，将两个项目累积成一个同类型的值。这里它就是对两个int求和。</li>
</ul>
</li>
<li><strong>单参数reducing工厂方法</strong>创建的收集器看作三参数方法的特殊情况，它<strong>把流中的第一个项目作为起点，把恒等函数（即一个函数仅仅是返回其输入参数）作为一个转换函数</strong>。这也意味着，要是把单参数reducing收集器传递给空流的collect方法，收集器就没有起点；因此而返回一个Optional<dish>对象。</dish></li>
<li>Stream接口的<strong><code>collect</code>和<code>reduce</code>方法</strong>有何不同<ul>
<li>reduce方法旨在把两个值结合起来生成一个新值，它是一个不可变的归约。</li>
<li>collect方法的设计就是要改变容器，从而累积要输出的结果。</li>
</ul>
</li>
<li><strong><code>counting</code>收集器</strong>也是类似地利用三参数reducing工厂方法实现的。它把流中的每个元素都转换成一个值为1的Long型对象，然后再把它们相加</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>计算菜单的总热量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> totalCalories1 = menu.stream()</span><br><span class="line">        .collect(reducing(<span class="number">0</span>, Dish::getCalories, (i, j) -&gt; i + j));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="keyword">int</span> totalCalories2 = menu.stream()</span><br><span class="line">        .collect(reducing(<span class="number">0</span>, Dish::getCalories, Integer::sum));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价, 但是 orElse或orElseGet来解开Optional中包含的值更为安全。</span></span><br><span class="line"><span class="comment">// reduce</span></span><br><span class="line"><span class="comment">// 避免自动拆箱操作</span></span><br><span class="line"><span class="keyword">int</span> totalCalories3 = menu.stream()</span><br><span class="line">        .map(Dish::getCalories)</span><br><span class="line">        .reduce(Integer::sum)</span><br><span class="line">        .get();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 等价</span></span><br><span class="line"><span class="keyword">int</span> totalCalories4 = menu.stream()</span><br><span class="line">        .mapToInt(Dish::getCalories) <span class="comment">// 映射为一个IntStream</span></span><br><span class="line">        .sum();</span><br></pre></td></tr></table></figure>
<p><strong>demo-2</strong></p>
<ul>
<li>找到热量最高的菜</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dish&gt; mostCalorieDish = menu.stream()</span><br><span class="line">        .collect(reducing((d1, d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2));</span><br></pre></td></tr></table></figure>
<p><strong>demo-3</strong></p>
<ul>
<li>用reducing连接字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line">String shortMenu = menu.stream()</span><br><span class="line">        .map(Dish::getName)</span><br><span class="line">        .collect( reducing ( (s1, s2) -&gt; s1 + s2 ) )</span><br><span class="line">        .get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line">String shortMenu = menu.stream()</span><br><span class="line">        <span class="comment">// 因为reducing接收的是一个BinaryOperator&lt;U&gt;, 看reducing的实现．</span></span><br><span class="line">        .collect( reducing( (d1, d2) -&gt; d1.getName() + d2.getName())) <span class="comment">// </span></span><br><span class="line">        .get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line">String shortMenu = menu.stream()</span><br><span class="line">        .collect( reducing( <span class="string">""</span>,Dish::getName, (s1, s2) -&gt; s1 + s2 ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reducing的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity,</span><br><span class="line">                                Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">                                BinaryOperator&lt;U&gt; op) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">                boxSupplier(identity),</span><br><span class="line">                (a, t) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], mapper.apply(t)); &#125;,</span><br><span class="line">                (a, b) -&gt; &#123; a[<span class="number">0</span>] = op.apply(a[<span class="number">0</span>], b[<span class="number">0</span>]); <span class="keyword">return</span> a; &#125;,</span><br><span class="line">                a -&gt; a[<span class="number">0</span>], CH_NOID);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><ul>
<li>给groupingBy方法传递了一个Function,分类函数，因为它用来把流中的元素分成不同的组。分组操作的结果是一个Map，<strong>把分组函数返回的值作为映射的键，把流中所有具有这个分类值的项目的列表作为对应的映射值</strong>。</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>把菜单中的菜按照类型进行分类，有肉的放一组，有鱼的放一组，其他的都放另一组。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType = menu.stream()</span><br><span class="line">        .collect(groupingBy(Dish::getType));</span><br><span class="line">&gt; output</span><br><span class="line">&#123;FISH=[prawns, salmon], MEAT=[pork, beef, chicken], OTHER=[french fries, rice, season fruit, pizza]&#125;</span><br></pre></td></tr></table></figure>
<p><strong>demo-2</strong></p>
<ul>
<li>把热量不到400卡路里的菜划分为“低热量”（diet），热量400到700卡路里的菜划为“普通”（normal），高于700卡路里的划为“高热量”（fat）,这里没有这样的一个方法引用，所以需要提供一个Lambda表达式．</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CaloricLevel &#123; DIET, NORMAL, FAT &#125;</span><br><span class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream().collect(</span><br><span class="line">                groupingBy(dish -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                &#125;));</span><br><span class="line">&gt; output</span><br><span class="line">&#123;DIET=[chicken, rice, season fruit, prawns], NORMAL=[beef, french fries, pizza, salmon], FAT=[pork]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多级分组"><a href="#多级分组" class="headerlink" title="多级分组"></a>多级分组</h3><ul>
<li>实现多级分组，我们可以使用一个由<strong>双参数版本的Collectors.groupingBy工厂方法创建的收集器</strong>，它除了普通的分类函数之外，还可以接受<strong>collector类型的第二个参数</strong>。</li>
<li>要进行二级分组的话，我们可以把一个内层groupingBy传递给外层groupingBy，并定义一个为流中项目分类的二级标准。这种多级分组操作可以扩展至任意层级， n级分组就会得到一个代表n级树形结构的n级<br>Map。</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>菜单中的菜肴同时按照类型和热量进行分组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; collect = menu.stream().collect(</span><br><span class="line">                <span class="comment">// 外层Map的键就是第一级分类函数生成的值：“ fish, meat, other”</span></span><br><span class="line">                groupingBy(Dish::getType, <span class="comment">// 一级分类函数</span></span><br><span class="line">                        <span class="comment">// 键是二级分类函数生成的值：“ normal, diet, fat”</span></span><br><span class="line">                        groupingBy((Dish dish) -&gt; &#123; <span class="comment">// 二级分类函数</span></span><br><span class="line">                            <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                        &#125;)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">&gt; output</span><br><span class="line">&#123;FISH=&#123;DIET=[prawns], NORMAL=[salmon]&#125;, MEAT=&#123;DIET=[chicken], NORMAL=[beef], FAT=[pork]&#125;, OTHER=&#123;DIET=[rice, season fruit], NORMAL=[french fries, pizza]&#125;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按子组收集数据"><a href="#按子组收集数据" class="headerlink" title="按子组收集数据"></a>按子组收集数据</h3><ul>
<li>传递给第一个groupingBy的第二个收集器可以是任何类型，而不一定是另一个groupingBy</li>
<li>普通的单参数groupingBy(f)（其中f是分类函数）实际上是groupingBy(f, toList())的简便写法。也就是第二个collector是toList()静态方法生成的收集器，即key对应的List列表值直接转为List即可．</li>
<li>demo2的maxBy实现中：Map中的值是<strong>Optional，因为这是maxBy工厂方法生成的收集器的类型</strong>，但实际上，如果菜单中没有某一类型的Dish，这个类型就不会对应一个<strong>Optional.empty()</strong>值，而且根本不会出现在Map的键中。<strong>groupingBy收集器只有在应用分组条件后，第一次在流中找到某个键对应的元素时才会把键加入分组Map中</strong>。</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>菜单中每类菜有多少个，可以传递counting收集器作为groupingBy收集器的第二个参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Long&gt; collect = menu.stream()</span><br><span class="line">                .collect(groupingBy(Dish::getType, counting()));</span><br><span class="line">&gt; output</span><br><span class="line">&#123;FISH=<span class="number">2</span>, MEAT=<span class="number">3</span>, OTHER=<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>demo-2</strong></p>
<ul>
<li>查找菜单不同分类中热量最高的菜肴</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现1</span></span><br><span class="line">Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; collect = menu.stream()</span><br><span class="line">            .collect(</span><br><span class="line">                <span class="comment">// 因为存在Stream为为空的情况．所以结果用Optional来包装起来．</span></span><br><span class="line">                groupingBy(Dish::getType,reducing((Dish d1, Dish d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2)));</span><br><span class="line">                        </span><br><span class="line"><span class="comment">// 实现2</span></span><br><span class="line">Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; collect = menu.stream()</span><br><span class="line">            .collect(groupingBy(Dish::getType, maxBy(comparingInt(Dish::getCalories))));</span><br><span class="line">                </span><br><span class="line"><span class="comment">// 实现3</span></span><br><span class="line">Map&lt;Dish.Type, Dish&gt; collect = menu.stream()</span><br><span class="line">            .collect(</span><br><span class="line">                groupingBy(Dish::getType,</span><br><span class="line">                        collectingAndThen(</span><br><span class="line">                                reducing((d1, d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2), Optional::get)</span><br><span class="line">                            )</span><br><span class="line">                    );</span><br><span class="line">&gt; output:</span><br><span class="line">&#123;FISH=Optional[salmon], MEAT=Optional[pork], OTHER=Optional[pizza]&#125;</span><br><span class="line">&#123;FISH=Optional[salmon], MEAT=Optional[pork], OTHER=Optional[pizza]&#125;</span><br><span class="line">&#123;FISH=salmon, MEAT=pork, OTHER=pizza&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// groupingBy的实现, 接收一个Function返回分类标准．后接一个Collector对象进行二次collect操作．</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt;</span><br><span class="line">    Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">                                          Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">        <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 把收集器的结果转换为另一种类型</span><br><span class="line">- 如上分组操作的Map结果中的每个值上包装的Optional没什么用，所以可能想要把它们去掉。要做到这一点，或者更一般地来说，**把收集器返回的结果转换为另一种类型**，你可以使用Collectors.collectingAndThen工厂方法返回的收集器</span><br><span class="line">- `Collectors.collectingAndThen`工厂方法接受两个参数 -- **要转换的收集器**以及**转换函数**，并**返回另一个收集器。这个收集器相当于旧收集器的一个包装**， collect(collectingAndThen)操作的最后一步就是将返回值用转换函数做一个映射。在这里，被包起来的收集器就是用maxBy建立的那个，而转换函数Optional::get则把返回的Optional中的值提取出来。</span><br><span class="line">- 执行过程</span><br><span class="line">    - groupingBy是最外层，根据菜肴的类型把菜单流分组，得到三个子流。</span><br><span class="line">    - groupingBy收集器包裹着collectingAndThen收集器，因此分组操作得到的每个子流都用这第二个收集器做进一步归约。</span><br><span class="line">    - collectingAndThen收集器又包裹着第三个收集器maxBy。</span><br><span class="line">    - 随后由归约收集器进行子流的归约操作，然后包含它的collectingAndThen收集器会对其结果应用Optional:get转换函数。</span><br><span class="line">    - 对三个子流分别执行这一过程并转换而得到的三个值，也就是各个类型中热量最高的Dish，将成为**groupingBy收集器返回的Map中与各个分类键（Dish的类型）相关联的值**。</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="comment">// 实现4</span></span><br><span class="line">Map&lt;Dish.Type, Dish&gt; collect = menu.stream()</span><br><span class="line">                .collect(groupingBy(Dish::getType,</span><br><span class="line">                        collectingAndThen(</span><br><span class="line">                                maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">                                Optional::get)));</span><br></pre></td></tr></table></figure>
<ul>
<li><img src="http://static.zybuluo.com/csqiang1992/wwtgcbuj14dw7tyro1yh6sw0/java8-groupby-1.png" alt="java8-groupby-1.png-115.2kB"></li>
</ul>
<h3 id="与groupingBy联合使用的其他收集器的例子"><a href="#与groupingBy联合使用的其他收集器的例子" class="headerlink" title="与groupingBy联合使用的其他收集器的例子"></a>与groupingBy联合使用的其他收集器的例子</h3><ul>
<li>通过groupingBy工厂方法的第二个参数传递的收集器将会对分到同一组中的所有流元素执行进一步归约操作。</li>
<li>常常和groupingBy联合使用的另一个收集器是mapping方法生成的。这个方法接受两个参数：一个函数对流中的元素做<strong>变换</strong>，另一个则将变换的结果对象<strong>收集</strong>起来。其目的是在累加之前对每个输入元素应用一个映射函数，这样就可以让接受特定类型元素的收集器适应不同类型的对象。</li>
<li><code>toSet()</code>对于返回的Set是什么类型并没有任何保证。但通过使用toCollection，你可以有更多的控制。</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>各个类型菜肴的热量总和</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Integer&gt; collect = menu.stream().collect(groupingBy(Dish::getType,</span><br><span class="line">                summingInt(Dish::getCalories)));</span><br><span class="line">                </span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p><strong>demo-2</strong></p>
<ul>
<li>对于每种类型的Dish，菜单中都有哪些CaloricLevel。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; collect = menu.stream().collect(</span><br><span class="line">                groupingBy(Dish::getType, mapping(</span><br><span class="line">                        dish -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">// 流中的元素累积到一个Set</span></span><br><span class="line">                        toSet())));</span><br><span class="line"><span class="comment">// 指定生成Hashset</span></span><br><span class="line">Map&lt;Dish.Type, HashSet&lt;CaloricLevel&gt;&gt; collect = menu.stream().collect(</span><br><span class="line">                groupingBy(Dish::getType, mapping(</span><br><span class="line">                        dish -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                        &#125;, toCollection(HashSet::<span class="keyword">new</span>)</span><br><span class="line">                ))</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><ul>
<li>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称<strong>分区函数</strong>。分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它<strong>最多可以分为两组</strong>——true是一组， false是一组。</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>把菜单按照素食和非素食分开</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu = enu.stream()</span><br><span class="line">        .collect(partitioningBy(Dish::isVegetarian));</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 所有的素食菜肴</span></span><br><span class="line">List&lt;Dish&gt; vegetarianDishes = partitionedMenu.get(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上等价于</span></span><br><span class="line">List&lt;Dish&gt; vegetarianDishes = menu.stream()</span><br><span class="line">        .filter(Dish::isVegetarian)</span><br><span class="line">        .collect(toList());</span><br><span class="line">&gt; output</span><br><span class="line">&#123;<span class="keyword">false</span>=[pork, beef, chicken, prawns, salmon], <span class="keyword">true</span>=[french fries, rice, season fruit, pizza]&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分区的优势"><a href="#分区的优势" class="headerlink" title="分区的优势"></a>分区的优势</h3><ul>
<li>分区的好处在于保留了分区函数返回true或false的两套流元素列表。同分组类似， partitioningBy工厂方法有一个重载版本，可以传递第二个收集器．</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>先按照素食与否分组，然后按类型对菜肴分组</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Map&lt;Dish.Type, List&lt;Dish&gt;&gt;&gt; collect = menu.stream()</span><br><span class="line">                .collect(partitioningBy(Dish::isVegetarian, </span><br><span class="line">                                groupingBy(Dish::getType)));</span><br><span class="line">&gt; output</span><br><span class="line"><span class="comment">// 二级Map：</span></span><br><span class="line">&#123;<span class="keyword">false</span>=&#123;FISH=[prawns, salmon], MEAT=[pork, beef, chicken]&#125;, <span class="keyword">true</span>=&#123;OTHER=[french fries, rice, season fruit, pizza]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>demo-2</strong></p>
<ul>
<li>素食和非素食中热量最高的菜</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Dish&gt; collect = menu.stream().collect(</span><br><span class="line">                partitioningBy(Dish::isVegetarian,</span><br><span class="line">                        collectingAndThen(</span><br><span class="line">                                <span class="comment">// maxBy的结果作用于get()</span></span><br><span class="line">                                maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">                                Optional::get)));</span><br><span class="line">                                </span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">&#123;<span class="keyword">false</span>=pork, <span class="keyword">true</span>=pizza&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将数字按质数和非质数分区"><a href="#将数字按质数和非质数分区" class="headerlink" title="将数字按质数和非质数分区"></a>将数字按质数和非质数分区</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试某一个待测数字是否是质数的谓词</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> candidate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.sqrt((<span class="keyword">double</span>) candidate);</span><br><span class="line">    <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, candidateRoot)</span><br><span class="line">            .noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含这n个数的流，用刚刚写的isPrime方法作为谓词，再给partitioningBy收集器归约</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimes(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, n).boxed()</span><br><span class="line">        .collect(partitioningBy(candidate -&gt; isPrime(candidate)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">&#123;<span class="keyword">false</span>=[<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>], <span class="keyword">true</span>=[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>]&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Collectors类的静态工厂方法能够创建的所有收集器"><a href="#Collectors类的静态工厂方法能够创建的所有收集器" class="headerlink" title="Collectors类的静态工厂方法能够创建的所有收集器"></a>Collectors类的静态工厂方法能够创建的所有收集器</h2><p><img src="http://static.zybuluo.com/csqiang1992/kcgv6uq4eptigqnx9qc832ww/java8-collectors-1.png" alt="java8-collectors-1.png-105.7kB"><br><img src="http://static.zybuluo.com/csqiang1992/g8cr6j29ixe0u06oq9f1dgm2/java8-collectors-2.png" alt="java8-collectors-2.png-176.8kB"><br><img src="http://static.zybuluo.com/csqiang1992/x2vg4kkxx9c17ipxactmycf7/java8-collectors-3.png" alt="java8-collectors-3.png-142.5kB"></p>
<hr>
<h2 id="收集器接口"><a href="#收集器接口" class="headerlink" title="收集器接口"></a>收集器接口</h2><p><strong>Collector.java</strong></p>
<ul>
<li><p>参数说明</p>
<ul>
<li>T是流中要收集的项目的泛型。</li>
<li>A是累加器的类型，累加器是在收集过程中用于累积部分结果的对象。</li>
<li>R是收集操作得到的对象（通常但并不一定是集合）的类型。</li>
</ul>
</li>
<li><p>实现一个<code>ToListCollector&lt;T&gt;</code>类，将<code>Stream&lt;T&gt;</code>中的所有元素收集到一个<code>List&lt;T&gt;</code>里，它的签名如下：<code>public class ToListCollector&lt;T&gt; implements Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt;</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A function that creates and returns a new mutable result container.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A function that folds a value into a mutable result container.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A function that accepts two partial results and merges them.  The</span></span><br><span class="line"><span class="comment">     * combiner function may fold state from one argument into the other and</span></span><br><span class="line"><span class="comment">     * return that, or may return a new result container.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回一个函数用于聚合结果．</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Perform the final transformation from the intermediate accumulation type</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> A&#125; to the final result type &#123;<span class="doctag">@code</span> R&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the characteristic &#123;<span class="doctag">@code</span> IDENTITY_TRANSFORM&#125; is</span></span><br><span class="line"><span class="comment">     * set, this function may be presumed to be an identity transform with an</span></span><br><span class="line"><span class="comment">     * unchecked cast from &#123;<span class="doctag">@code</span> A&#125; to &#123;<span class="doctag">@code</span> R&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 返回一个函数用于将中间结果转换为最终结果．</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@code</span> Set&#125; of &#123;<span class="doctag">@code</span> Collector.Characteristics&#125; indicating</span></span><br><span class="line"><span class="comment">     * the characteristics of this Collector.  This set should be immutable.</span></span><br><span class="line"><span class="comment">     * 提供了一系列特征，也就是一个提示列表，告诉collect方法在执行归约操作的时候可以应用哪优</span></span><br><span class="line"><span class="comment">     * 化（比如并行化）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T, R&gt; Collector&lt;T, R, R&gt; <span class="title">of</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              BiConsumer&lt;R, T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              BinaryOperator&lt;R&gt; combiner,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Characteristics... characteristics)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(supplier);</span><br><span class="line">        Objects.requireNonNull(accumulator);</span><br><span class="line">        Objects.requireNonNull(combiner);</span><br><span class="line">        Objects.requireNonNull(characteristics);</span><br><span class="line">        Set&lt;Characteristics&gt; cs = (characteristics.length == <span class="number">0</span>)</span><br><span class="line">                                  ? Collectors.CH_ID</span><br><span class="line">                                  : Collections.unmodifiableSet(EnumSet.of(Collector.Characteristics.IDENTITY_FINISH,</span><br><span class="line">                                                                           characteristics));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Collectors.CollectorImpl&lt;&gt;(supplier, accumulator, combiner, cs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">enum</span> Characteristics &#123;</span><br><span class="line">        </span><br><span class="line">        CONCURRENT,</span><br><span class="line">        UNORDERED,</span><br><span class="line">        IDENTITY_FINISH</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="理解-Collector-接口声明的方法"><a href="#理解-Collector-接口声明的方法" class="headerlink" title="理解 Collector 接口声明的方法"></a>理解 Collector 接口声明的方法</h3><h4 id="supplier方法-建立新的结果容器"><a href="#supplier方法-建立新的结果容器" class="headerlink" title="supplier方法: 建立新的结果容器"></a>supplier方法: 建立新的结果容器</h4><ul>
<li>supplier方法必须返回一个结果为空的Supplier，也就是一个无参数函数，在调用时它会创建一个空的累加器实例，供数据收集过程使用。</li>
<li>在我们的ToListCollector中， supplier返回一个空的List</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">    <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只传递一个构造函数引用：</span></span><br><span class="line"><span class="keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">    <span class="keyword">return</span> ArrayList::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="accumulator方法-将元素添加到结果容器"><a href="#accumulator方法-将元素添加到结果容器" class="headerlink" title="accumulator方法: 将元素添加到结果容器"></a>accumulator方法: 将元素添加到结果容器</h4><ul>
<li>accumulator方法会返回执行<strong>归约操作</strong>的函数。当遍历到流中第n个元素时，这个函数执行时会有两个参数：保存归约结果的累加器（已收集了流中的前n-1个项目），还有第n个元素本身。该函数将返回void，因为累加器是原位更新，即函数的执行改变了它的内部状态以体现遍历的元素的效果。</li>
<li>ToListCollector，这个函数仅仅会把当前项目添加至已经遍历过的项目的列表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">    <span class="keyword">return</span> (list, item) -&gt; list.add(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line"><span class="keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">    <span class="keyword">return</span> List::add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="finisher方法-对结果容器应用最终转换"><a href="#finisher方法-对结果容器应用最终转换" class="headerlink" title="finisher方法: 对结果容器应用最终转换"></a>finisher方法: 对结果容器应用最终转换</h4><ul>
<li>遍历完流后， finisher方法必须返回在累积过程的最后要调用的一个函数，以便<strong>将累加器对象转换为整个集合操作的最终结果</strong>。</li>
<li>ToListCollector实现中，<strong>累加器对象恰好符合预期的最终结果</strong>（也是一个List），因此无需进行转换。所以finisher方法只需返回identity函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() &#123;  </span><br><span class="line">    <span class="keyword">return</span> Function.identity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="顺序归约过程的逻辑步骤"><a href="#顺序归约过程的逻辑步骤" class="headerlink" title="顺序归约过程的逻辑步骤"></a>顺序归约过程的逻辑步骤</h4><p><img src="http://static.zybuluo.com/csqiang1992/jl7hvwfr1cfmr73zwn7l4za2/java8-sequentail-reduce-1.png" alt="java8-sequentail-reduce-1.png-61.8kB"></p>
<h4 id="combiner方法-合并两个结果容器"><a href="#combiner方法-合并两个结果容器" class="headerlink" title="combiner方法: 合并两个结果容器"></a>combiner方法: 合并两个结果容器</h4><ul>
<li>combiner方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，<strong>各个子部分归约所得的累加器要如何合并</strong>。</li>
<li>ToListCollector的实现只要把从流的第二个部分收集到的项目列表加到遍历第一部分</li>
<li><ul>
<li>原始流会以递归方式拆分为子流;所有的子流都可以并行处理,而每个子流都采用如上的顺序归约过程，然后使用收集器combiner方法返回的函数，将所有的部分结果两两合并。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BinaryOperator&lt;List&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">    <span class="keyword">return</span> (list1, list2) -&gt; &#123;</span><br><span class="line">        list1.addAll(list2);</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="characteristics方法"><a href="#characteristics方法" class="headerlink" title="characteristics方法"></a>characteristics方法</h4><ul>
<li>定义了收集器的行为 – 尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示<ul>
<li>UNORDERED – 归约结果不受流中项目的遍历和累积顺序的影响。</li>
<li>CONCURRENT – accumulator函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为UNORDERED，那它仅在用于无序数据源时才可以并行归约。</li>
<li>IDENTITY_FINISH – 这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，<strong>累加器对象将会直接用作归约过程的最终结果</strong>。这也意味着，将累加器A不加检查地转换为结果R是安全的。</li>
</ul>
</li>
</ul>
<p><strong>ToListCollector.java</strong>    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToListCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">List</span>&lt;<span class="title">T</span>&gt;, <span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        <span class="keyword">return</span> (list, item) -&gt; list.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() &#123;</span><br><span class="line">        <span class="keyword">return</span> i -&gt; i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;List&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        <span class="keyword">return</span> (list1, list2) -&gt; &#123;</span><br><span class="line">            list1.addAll(list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH, CONCURRENT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用, new 来初始化</span></span><br><span class="line">List&lt;Dish&gt; dishes = menuStream.collect(<span class="keyword">new</span> ToListCollector&lt;Dish&gt;());</span><br><span class="line"><span class="comment">// 标准实现</span></span><br><span class="line">List&lt;Dish&gt; dishes = menuStream.collect(toList());</span><br></pre></td></tr></table></figure>
<h3 id="collect方法重载版本"><a href="#collect方法重载版本" class="headerlink" title="collect方法重载版本"></a>collect方法重载版本</h3><ul>
<li>对于<code>IDENTITY_FINISH</code> (Finisher做的就是横等变换，所以不需要提供) 的收集操作，还可以使用Stream的一个重载方法来实现类似Collector的功能。Stream有一个重载的collect方法可以接受另外三个函数——<strong>supplier、accumulator和combiner</strong>，其语义和Collector接口的相应方法返回的函数完全相同。</li>
<li>这种重载的collect方法不能传递任何Characteristics，所以它永远都是一个IDENTITY_FINISH和CONCURRENT但并非UNORDERED的收集器。</li>
</ul>
<p><strong>demo-1</strong></p>
<ul>
<li>把菜肴流中的项目收集到一个List中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; dishes = menuStream.collect(</span><br><span class="line">        ArrayList::<span class="keyword">new</span>,</span><br><span class="line">        List::add,</span><br><span class="line">        List::addAll);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="开发你自己的收集器以获得更好的性能"><a href="#开发你自己的收集器以获得更好的性能" class="headerlink" title="开发你自己的收集器以获得更好的性能"></a>开发你自己的收集器以获得更好的性能</h2><h3 id="利用collect方法来划分质数和非质数"><a href="#利用collect方法来划分质数和非质数" class="headerlink" title="利用collect方法来划分质数和非质数"></a>利用collect方法来划分质数和非质数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimes(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, n).boxed()</span><br><span class="line">        .collect(partitioningBy(candidate -&gt; isPrime(candidate));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制除数不超过被测试数的平方根</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> candidate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.sqrt((<span class="keyword">double</span>) candidate);</span><br><span class="line">    <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, candidateRoot)</span><br><span class="line">        .noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义收集器来划分质数和非质数"><a href="#自定义收集器来划分质数和非质数" class="headerlink" title="自定义收集器来划分质数和非质数"></a>自定义收集器来划分质数和非质数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionPrimeNumbers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Numbers partitioned in prime and non-prime: "</span> + partitionPrimes(<span class="number">20</span>));</span><br><span class="line">        System.out.println(<span class="string">"Numbers partitioned in prime and non-prime: "</span> + partitionPrimesWithCustomCollector(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimes(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, n).boxed()</span><br><span class="line">                .collect(partitioningBy(candidate -&gt; isPrime(candidate)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimesWithCustomCollector(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, n).boxed().collect(<span class="keyword">new</span> PrimeNumbersCollector());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> candidate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.rangeClosed(<span class="number">2</span>, candidate - <span class="number">1</span>)</span><br><span class="line">                .limit((<span class="keyword">long</span>) Math.floor(Math.sqrt((<span class="keyword">double</span>) candidate)) - <span class="number">1</span>)</span><br><span class="line">                .noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(List&lt;Integer&gt; primes, Integer candidate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> candidateRoot = Math.sqrt((<span class="keyword">double</span>) candidate);</span><br><span class="line">        <span class="keyword">return</span> takeWhile(primes, i -&gt; i &lt;= candidateRoot).stream().noneMatch(i -&gt; candidate % i == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// takeWhile实现是即时的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">List&lt;A&gt; <span class="title">takeWhile</span><span class="params">(List&lt;A&gt; list, Predicate&lt;A&gt; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (A item : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p.test(item)) &#123; <span class="comment">// //只要求list中所有满足p的item, 也就是所有小于root的item(都是质数), 进一步比sqrt快了.</span></span><br><span class="line">                <span class="keyword">return</span> list.subList(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * public interface Collector&lt;T, A, R&gt;</span></span><br><span class="line"><span class="comment">     * 其中T、 A和R分别是流中元素的类型、用于累积部分结果的对象类型，以及collect操作最</span></span><br><span class="line"><span class="comment">     * 终结果的类型。这里应该收集Integer流，而累加器和结果类型则都是 Map&lt;Boolean,</span></span><br><span class="line"><span class="comment">     * List&lt;Integer&gt;&gt; 键是true和false，值则分别是质数和非质数的List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNumbersCollector</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">Integer</span>, <span class="title">Map</span>&lt;<span class="title">Boolean</span>, <span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt;, <span class="title">Map</span>&lt;<span class="title">Boolean</span>, <span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建累加器并进行初始化，为true和false两个键下面初始化了对应的空列表。</span></span><br><span class="line"><span class="comment">         * 在收集过程中会把质数和非质数分别添加到这里</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Supplier&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; supplier() &#123;</span><br><span class="line">            <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> HashMap&lt;Boolean, List&lt;Integer&gt;&gt;() &#123;&#123;</span><br><span class="line">                put(<span class="keyword">true</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">                put(<span class="keyword">false</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">            &#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> BiConsumer&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;, Integer&gt; accumulator() &#123;</span><br><span class="line">            <span class="keyword">return</span> (Map&lt;Boolean, List&lt;Integer&gt;&gt; acc, Integer candidate) -&gt; &#123;</span><br><span class="line">                acc.get(isPrime(acc.get(<span class="keyword">true</span>), candidate)) <span class="comment">// 根据isPrime的结果，获取质数或非质数列表</span></span><br><span class="line">                        .add(candidate); <span class="comment">// 将被测数添加到相应的列表中</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 合并两个Map，即将第二个Map中质数和非质数列表中的所有数字合并到第一个Map的对应列表即可</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 本例子中这个收集器是不能并行使用的，因为该算法本身是顺序的。</span></span><br><span class="line"><span class="comment">         * 这意味着永远都不会调用combiner方法，你可以把它的实现留空</span></span><br><span class="line"><span class="comment">         * （更好的做法是抛出一个UnsupportedOperationException异常）</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> BinaryOperator&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; combiner() &#123;</span><br><span class="line">            <span class="keyword">return</span> (Map&lt;Boolean, List&lt;Integer&gt;&gt; map1, Map&lt;Boolean, List&lt;Integer&gt;&gt; map2) -&gt; &#123;</span><br><span class="line">                map1.get(<span class="keyword">true</span>).addAll(map2.get(<span class="keyword">true</span>));</span><br><span class="line">                map1.get(<span class="keyword">false</span>).addAll(map2.get(<span class="keyword">false</span>));</span><br><span class="line">                <span class="keyword">return</span> map1;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * accumulator正好就是收集器的结果，</span></span><br><span class="line"><span class="comment">         * 用不着进一步转换，那么finisher方法就返回identity函数</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Function&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;, Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; finisher() &#123;</span><br><span class="line">            <span class="comment">//  return i -&gt; i; // 也可以</span></span><br><span class="line">            <span class="keyword">return</span> Function.identity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 既不是CONCURRENT也不是UNORDERED，但却是IDENTITY_FINISH的</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="比较收集器的性能"><a href="#比较收集器的性能" class="headerlink" title="比较收集器的性能"></a>比较收集器的性能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectorHarness</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Partitioning done in: "</span> + execute(PartitionPrimeNumbers::partitionPrimes) + <span class="string">" msecs"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Partitioning done in: "</span> + execute(PartitionPrimeNumbers::partitionPrimesWithCustomCollector) + <span class="string">" msecs"</span> );</span><br><span class="line">        System.out.println(<span class="string">"Partitioning done in: "</span> + execute(PartitionPrimeNumbers::partitionPrimesWithInlineCollector) + <span class="string">" msecs"</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">execute</span><span class="params">(Consumer&lt;Integer&gt; primePartitioner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> fastest = Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">            primePartitioner.accept(<span class="number">1_000_000</span>);</span><br><span class="line">            <span class="keyword">long</span> duration = (System.nanoTime() - start) / <span class="number">1_000_000</span>;</span><br><span class="line">            <span class="keyword">if</span> (duration &lt; fastest) fastest = duration;</span><br><span class="line">            System.out.println(<span class="string">"done in "</span> + duration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fastest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// time explicity</span></span><br><span class="line">done in <span class="number">1524</span></span><br><span class="line">done in <span class="number">1392</span></span><br><span class="line">done in <span class="number">1378</span></span><br><span class="line">done in <span class="number">1349</span></span><br><span class="line">done in <span class="number">1275</span></span><br><span class="line">done in <span class="number">1380</span></span><br><span class="line">done in <span class="number">1255</span></span><br><span class="line">done in <span class="number">1253</span></span><br><span class="line">done in <span class="number">1258</span></span><br><span class="line">done in <span class="number">1253</span></span><br><span class="line">Partitioning done in: <span class="number">1253</span> msecs</span><br><span class="line">done in <span class="number">790</span></span><br><span class="line">done in <span class="number">554</span></span><br><span class="line">done in <span class="number">544</span></span><br><span class="line">done in <span class="number">616</span></span><br><span class="line">done in <span class="number">623</span></span><br><span class="line">done in <span class="number">598</span></span><br><span class="line">done in <span class="number">603</span></span><br><span class="line">done in <span class="number">636</span></span><br><span class="line">done in <span class="number">602</span></span><br><span class="line">done in <span class="number">600</span></span><br><span class="line">Partitioning done in: <span class="number">544</span> msecs</span><br><span class="line">done in <span class="number">632</span></span><br><span class="line">done in <span class="number">628</span></span><br><span class="line">done in <span class="number">622</span></span><br><span class="line">done in <span class="number">617</span></span><br><span class="line">done in <span class="number">613</span></span><br><span class="line">done in <span class="number">622</span></span><br><span class="line">done in <span class="number">624</span></span><br><span class="line">done in <span class="number">656</span></span><br><span class="line">done in <span class="number">619</span></span><br><span class="line">done in <span class="number">620</span></span><br><span class="line">Partitioning done in: <span class="number">613</span> msecs</span><br></pre></td></tr></table></figure>
<h3 id="collect方法的重载版本来划分质数和非质数"><a href="#collect方法的重载版本来划分质数和非质数" class="headerlink" title="collect方法的重载版本来划分质数和非质数"></a>collect方法的重载版本来划分质数和非质数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimesWithInlineCollector(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(<span class="number">2</span>, i -&gt; i + <span class="number">1</span>).limit(n)</span><br><span class="line">                .collect(</span><br><span class="line">                        <span class="comment">// supplier</span></span><br><span class="line">                        () -&gt; <span class="keyword">new</span> HashMap&lt;Boolean, List&lt;Integer&gt;&gt;() &#123;&#123;</span><br><span class="line">                            put(<span class="keyword">true</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">                            put(<span class="keyword">false</span>, <span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">                        &#125;&#125;,</span><br><span class="line">                        <span class="comment">// accumulator</span></span><br><span class="line">                        (acc, candidate) -&gt; &#123;</span><br><span class="line">                            acc.get(isPrime(acc.get(<span class="keyword">true</span>), candidate))</span><br><span class="line">                                    .add(candidate);</span><br><span class="line">                        &#125;,</span><br><span class="line">                        <span class="comment">// combiner</span></span><br><span class="line">                        (map1, map2) -&gt; &#123;</span><br><span class="line">                            map1.get(<span class="keyword">true</span>).addAll(map2.get(<span class="keyword">true</span>));</span><br><span class="line">                            map1.get(<span class="keyword">false</span>).addAll(map2.get(<span class="keyword">false</span>));</span><br><span class="line">                        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>collect是一个终端操作，它接受的参数是<strong>将流中元素累积到汇总结果</strong>的各种方式（称为<strong>收集器</strong>）。</li>
<li>预定义收集器包括将流元素归约和汇总到一个值，例如计算最小值、最大值或平均值。</li>
<li>预定义收集器可以用<strong>groupingBy对流中元素进行分组</strong>，或用<strong>partitioningBy进行分区</strong>。</li>
<li>收集器可以高效地复合起来，进行多级分组、分区和归约。</li>
<li>你可以实现Collector接口中定义的方法来开发你自己的收集器。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/Java8/" rel="tag"># Java8</a>
          
            <a href="/tags/函数式编程/" rel="tag"># 函数式编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/26/java8-stream-operations/" rel="next" title="Java8-使用流">
                <i class="fa fa-chevron-left"></i> Java8-使用流
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/29/java8-CompletableFuture-in-practise/" rel="prev" title="Java8-CompletableFuture组合式异步编程">
                Java8-CompletableFuture组合式异步编程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/self.jpg"
                alt="darcy" />
            
              <p class="site-author-name" itemprop="name">darcy</p>
              <p class="site-description motion-element" itemprop="description">Do Have Patience In What You LOVE.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="http://douban.com/people/70670266" target="_blank" title="douban">
                      
                        <i class="fa fa-fw fa-globe"></i>douban</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.zhenlanghuo.top/" title="zhenlang huo" target="_blank">zhenlang huo</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://xawei.me/" title="xinan wei" target="_blank">xinan wei</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#收集器简介"><span class="nav-number">1.</span> <span class="nav-text">收集器简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归约和汇总"><span class="nav-number">2.</span> <span class="nav-text">归约和汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查找流中的最大值和最小值"><span class="nav-number">2.1.</span> <span class="nav-text">查找流中的最大值和最小值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#汇总"><span class="nav-number">2.2.</span> <span class="nav-text">汇总</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接字符串"><span class="nav-number">2.3.</span> <span class="nav-text">连接字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#广义的归约汇总"><span class="nav-number">2.4.</span> <span class="nav-text">广义的归约汇总</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分组"><span class="nav-number">3.</span> <span class="nav-text">分组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多级分组"><span class="nav-number">3.1.</span> <span class="nav-text">多级分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按子组收集数据"><span class="nav-number">3.2.</span> <span class="nav-text">按子组收集数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#与groupingBy联合使用的其他收集器的例子"><span class="nav-number">3.3.</span> <span class="nav-text">与groupingBy联合使用的其他收集器的例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分区"><span class="nav-number">4.</span> <span class="nav-text">分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分区的优势"><span class="nav-number">4.1.</span> <span class="nav-text">分区的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将数字按质数和非质数分区"><span class="nav-number">4.2.</span> <span class="nav-text">将数字按质数和非质数分区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collectors类的静态工厂方法能够创建的所有收集器"><span class="nav-number">5.</span> <span class="nav-text">Collectors类的静态工厂方法能够创建的所有收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#收集器接口"><span class="nav-number">6.</span> <span class="nav-text">收集器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#理解-Collector-接口声明的方法"><span class="nav-number">6.1.</span> <span class="nav-text">理解 Collector 接口声明的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#supplier方法-建立新的结果容器"><span class="nav-number">6.1.1.</span> <span class="nav-text">supplier方法: 建立新的结果容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#accumulator方法-将元素添加到结果容器"><span class="nav-number">6.1.2.</span> <span class="nav-text">accumulator方法: 将元素添加到结果容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finisher方法-对结果容器应用最终转换"><span class="nav-number">6.1.3.</span> <span class="nav-text">finisher方法: 对结果容器应用最终转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序归约过程的逻辑步骤"><span class="nav-number">6.1.4.</span> <span class="nav-text">顺序归约过程的逻辑步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#combiner方法-合并两个结果容器"><span class="nav-number">6.1.5.</span> <span class="nav-text">combiner方法: 合并两个结果容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#characteristics方法"><span class="nav-number">6.1.6.</span> <span class="nav-text">characteristics方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#collect方法重载版本"><span class="nav-number">6.2.</span> <span class="nav-text">collect方法重载版本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发你自己的收集器以获得更好的性能"><span class="nav-number">7.</span> <span class="nav-text">开发你自己的收集器以获得更好的性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#利用collect方法来划分质数和非质数"><span class="nav-number">7.1.</span> <span class="nav-text">利用collect方法来划分质数和非质数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义收集器来划分质数和非质数"><span class="nav-number">7.2.</span> <span class="nav-text">自定义收集器来划分质数和非质数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比较收集器的性能"><span class="nav-number">7.3.</span> <span class="nav-text">比较收集器的性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#collect方法的重载版本来划分质数和非质数"><span class="nav-number">7.4.</span> <span class="nav-text">collect方法的重载版本来划分质数和非质数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">8.</span> <span class="nav-text">小结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">darcy</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count"></span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("nDVrc1Rvjlwx4V9XScsLSm9q-gzGzoHsz", "4ONqgToWREwRHxcX9qRXFhlL");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
